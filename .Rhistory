xx <- sqrt(rgamma(1, alpha/2, delta_opt))
uu <- log(runif(1))
aa <- -(beta-delta_opt)*xx^2 + gamma*xx - gamma^2/(4*(beta-delta_opt))
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
# Sample with algorithm 1
# Case one (K1 < K2)
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- sqrt(rgamma(1, alpha/2, delta_opt))
uu <- log(runif(1))
aa <- -(beta-delta_opt)*xx^2 + gamma*xx - gamma^2/(4*(beta-delta_opt))
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
xx
cnt
max_steps
mu
K1
K2
K1 < K2
gamma <- gamma0
pi
?lgamma
lgamma(250)
log(gamma(250))
lgamma(100)
gamma(100)
log(gamma(100))
lgamma(10000)
lgamma(1e6)
mu_opt
mu
dmpon
curve(dmpon(x, alpha, gamma0, mu))
abline(v=mu_opt)
abline(v=mu)
mu
mu_opt
0.5 < 0.7
log(0.5) < log(0.7)
# Sample with algorithm 1
# Case one (K1 < K2)
cnt <- 1
xx <- rnorm(1, mu_opt, sqrt(1/(2*beta)))
uu <- log(runif(1))
uu
xx
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa
xx
abline(v=xx, col='red')
curve(dmpon(x, alpha, gamma0, mu), from=0.6, to=0.8)
curve(dnorm(x, mu_opt, sqrt(1/(2*beta))), add=TRUE, col='blue')
curve(dnorm(x, mu_opt, sqrt(1/(2*beta))), add=TRUE, col='blue')
mu_opt
cc <- integrate(dmpon(x, alpha, gamma0, mu), from=0.6, to=0.8)
cc <- integrate(function(x) dmpon(x, alpha, gamma0, mu), from=0.6, to=0.8)
cc <- integrate(function(x) dmpon(x, alpha, gamma0, mu), lower=0.6, upper=0.8)
cc
cc$value
cc <- cc$value
curve(dmpon(x, alpha, gamma0, mu)/cc, from=0.6, to=0.8)
curve(dnorm(x, mu_opt, sqrt(1/(2*beta))), add=TRUE, col='blue')
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
#aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + x*(gamma - 2*mu_opt*beta) + alpha - 1
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
#aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
aa
# Sample with algorithm 1
# Case one (K1 < K2)
cnt <- 1
while(TRUE){
xx <- rnorm(1, mu_opt, sqrt(1/(2*beta)))
uu <- log(runif(1))
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
#aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
foo <- rgamma(100000, alpha/2, delta_opt)
foo <- sqrt(foo)
hist(foo, breaks=60, freq=FALSE, add=T)
cnt <- cnt + 1
while(TRUE){
xx <- sqrt(rgamma(1, alpha/2, delta_opt))
uu <- log(runif(1))
aa <- -(beta-delta_opt)*xx^2 + gamma*xx - gamma^2/(4*(beta-delta_opt))
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
cnt
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- rnorm(1, mu_opt, sqrt(1/(2*beta)))
uu <- log(runif(1))
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
#aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- sqrt(rgamma(1, alpha/2, delta_opt))
uu <- log(runif(1))
aa <- -(beta-delta_opt)*xx^2 + gamma*xx - gamma^2/(4*(beta-delta_opt))
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
gamma <- gamma0
# Reparameterize in terms of Sun et al. (2021)
beta <- gamma
gamma <- 2*mu*beta
# Calculate optimal choices of enevelope parameters (Thm 1)
mu_opt    <- (gamma + sqrt(gamma^2 + 8*(alpha - 1)*beta))/(4*beta)
delta_opt <- beta + (gamma^2 - gamma*sqrt(gamma^2 + 8*alpha*beta))/(4*alpha)
# Compute K1 and K2 (Thm 1)
ka1 <- log(2*sqrt(pi)) + (alpha-1)*log(sqrt(beta)*(alpha-1)/(2*beta*mu_opt-gamma))
kb1 <- -(alpha-1)+beta*mu_opt^2
K1  <- ka1 + kb1
ka2 <- (alpha/2)*log(beta) + lgamma(alpha/2) - alpha/2*log(delta_opt)
kb2 <- (gamma^2/(4*(beta-delta_opt)))
K2  <- ka2 + kb2
K1
K2
K1 < K2
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- rnorm(1, mu_opt, sqrt(1/(2*beta)))
uu <- log(runif(1))
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
#aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
cnt
xx
xx > 0
uu < aa
xx > 0 & uu < aa
# Sample with algorithm 1
# Case one (K1 < K2)
if(K1 < K2){
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- rnorm(1, mu_opt, sqrt(1/(2*beta)))
uu <- log(runif(1))
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
aa <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
#aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
}
#aa <- xx^(alpha-1)/mu_opt*exp((2*beta*mu-gamma)*(mu_opt-xx))
aa1 <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
aa1
aa
#' alpha <- 5
#' gamma <- 1
#' mu <- 2
#' y <- rep(NA, n)
#' for(i in 1:n){
#'   y[i] <- rmpon(1, alpha, gamma, mu)
#' }
#' hist(y, breaks=30, freq=F)
#' c <- integrate(dmpon, lower=0, upper=20, alpha=alpha, gamma=gamma, mu=mu)$value
#' curve(dmpon(x, alpha, gamma, mu)/c, add=TRUE, lwd=2, col='blue')
rmpon_sun <- function(n=1, alpha, gamma, mu, max_steps=1e6){
# Reparameterize in terms of Sun et al. (2021)
beta <- gamma
gamma <- 2*mu*beta
# Calculate optimal choices of enevelope parameters (Thm 1)
mu_opt    <- (gamma + sqrt(gamma^2 + 8*(alpha - 1)*beta))/(4*beta)
delta_opt <- beta + (gamma^2 - gamma*sqrt(gamma^2 + 8*alpha*beta))/(4*alpha)
# Compute K1 and K2 (Thm 1)
ka1 <- log(2*sqrt(pi)) + (alpha-1)*log(sqrt(beta)*(alpha-1)/(2*beta*mu_opt-gamma))
kb1 <- -(alpha-1)+beta*mu_opt^2
K1  <- ka1 + kb1
ka2 <- (alpha/2)*log(beta) + lgamma(alpha/2) - alpha/2*log(delta_opt)
kb2 <- (gamma^2/(4*(beta-delta_opt)))
K2  <- ka2 + kb2
# Sample with algorithm 1
# Case one (K1 < K2)
if(K1 < K2){
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- rnorm(1, mu_opt, sqrt(1/(2*beta)))
uu <- log(runif(1))
#aa1 <- (alpha-1)*log(xx) - log(mu_opt) + (2*beta*mu_opt-gamma)*(mu_opt-xx)
aa <- (alpha-1)*log(xx*(2*beta*mu_opt - gamma)/(alpha-1)) + xx*(gamma - 2*mu_opt*beta) + alpha - 1
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
}
# Case two (K1 >= K2)
else{
cnt <- 1
while(TRUE){
cnt <- cnt + 1
xx <- sqrt(rgamma(1, alpha/2, delta_opt))
uu <- log(runif(1))
aa <- -(beta-delta_opt)*xx^2 + gamma*xx - gamma^2/(4*(beta-delta_opt))
if(xx > 0 & uu < aa){
return(xx)
}
if(cnt > max_steps){
stop("More than 1e9 iterations needed
to obtain a sample from modified half normal\n
\n\talpha: ", alpha,
"\n\tgamma: ", beta,
"\n\tmu: ", mu)
}
}
}
}
curve(dmpon(x, alpha, gamma0, mu)/cc, from=0.6, to=0.8)
foo <- unlist(lapply(1:10000), function(x) rmpon(1, alpha, gamma0, mu))
foo <- unlist(lapply(1:10000, function(x) rmpon(1, alpha, gamma0, mu)))
hist(foo, freq=F, breaks=30, add=T)
cnt
alpha <- 500
gamma <- 4000
mu <- 0.5
# Reparameterize in terms of Sun et al. (2021)
beta <- gamma
gamma <- 2*mu*beta
beta
gamma
mu
alpha <- 5
gamma <- 4
gamma <- 3
beta <- 4
# Calculate optimal choices of enevelope parameters (Thm 1)
mu_opt    <- (gamma + sqrt(gamma^2 + 8*(alpha - 1)*beta))/(4*beta)
delta_opt <- beta + (gamma^2 - gamma*sqrt(gamma^2 + 8*alpha*beta))/(4*alpha)
# Compute K1 and K2 (Thm 1)
ka1 <- log(2*sqrt(pi)) + (alpha-1)*log(sqrt(beta)*(alpha-1)/(2*beta*mu_opt-gamma))
kb1 <- -(alpha-1)+beta*mu_opt^2
K1  <- ka1 + kb1
ka2 <- (alpha/2)*log(beta) + lgamma(alpha/2) - alpha/2*log(delta_opt)
kb2 <- (gamma^2/(4*(beta-delta_opt)))
K2  <- ka2 + kb2
K1 < K2
library(MHN)
xx <- rMHN(10000, 500, 4000, 4000)
hist(xx, breaks=30, freq=FALSE)
?dMHN
?MHN::rMHN
hist(xx, breaks=30, freq=FALSE)
cc <- integrate(dmpon, lower=0.5, upper=0.7, alpha=500, gamma=4000, mu=0.5)
curve(dmpon(x, 500, 4000, 0.5)/cc, add=TRUE, lwd=2, col='dodgerblue')
?dmpon
cc <- integrate(dmpon, lower=0.5, upper=0.7, alpha=500, gamma=4000, mu=0.5)$value
curve(dmpon(x, 500, 4000, 0.5)/cc, add=TRUE, lwd=2, col='dodgerblue')
?rMHN
rMHN
rMHN_gamma_positive_N()
rMHN_gamma_positive_N
log(0)
log(-1)
document()
library(GBASS)
document()
w_prior=list(type="GIG", p=0, a=0, b=0, prop_sigma=0.2)
maxInt
maxInt=2
maxBasis=1000
npart=NULL
nmcmc=10000
nburn=9001
thin=1
moveProbs=rep(1/3,3)
a_tau = 1/2
b_tau = NULL
a_lambda = b_lambda = 1
m_beta=0
s_beta=0.1
lag_beta=1
m_gamma=100
s_gamma=35
vsig=0.25
scale=1
Iw0 = rep(1, maxInt)
Zw0 = rep(1, ncol(X))
X <- lhs::maximinLHS(500, 2)
y <- apply(X, 1, duqling::dms_simple)
Zw0 = rep(1, ncol(X))
v_prior <- list(type="GIG", p=-1/2, a=1, b=1, prop_sigma=vsig)
if(nrow(X) != length(y)) stop("nrow(X) and length(y) should match")
if(lag_beta > nburn){
lag_beta <- nburn
warning("lag_beta cannot exceed nburn. Setting lag_beta = nburn")
}
s_beta_hold <- s_beta
if(lag_beta > 0){
s_beta <- 0
}
s_beta = s_beta_hold
lag_beta = 0
s_beta_hold <- s_beta
if(lag_beta > 0){
s_beta <- 0
}
s_beta
N <- nrow(X)
p <- ncol(X)
nkeep <- length(seq(nburn, nmcmc, by=thin))
if(is.null(npart)) npart <- min(20, 0.1*N)
if(is.null(b_tau)) b_tau <- N/2
if(is.null(w_prior$lb)) w_prior$lb <- 1/N
if(is.null(v_prior$lb)) v_prior$lb <- 0
#ALLOCATE STORAGE SPACE
a_mc <- list()
M_mc <- lam_mc <- tau_mc <- w_mc <- bet_mc <- gam_mc <- ss <- rep(NA, nkeep)
v_mc   <- matrix(NA, nrow=nkeep, ncol=N)
lookup <- basis_mc <- list()
basis_index <- integer(0)
nlook <- 1
kk    <- 1
#INITIALIZE PARAMETERS
M   <- 0
tau <- (b_tau+.1)/(a_tau+.1)
gam <- 1
v   <- rep(1, N)
w   <- 1*var(y)/scale #Multiply by 2 tries to avoid collapsing to degenerate solution
lam <- rgamma(1, a_lambda, b_lambda)
bet <- rnorm(1, m_beta, s_beta)
a   <- mean(y)
z    <- y - bet*v*sqrt(w)
B    <- matrix(1, nrow=N)
Vinv <- Matrix::Diagonal(x=1/v)
U    <- solve(symchol(t(B)%*%Vinv%*%B + scale/tau*Diagonal(M+1)))
U2   <- t(z/v)%*%B%*%U
cnt1 <- cnt2 <- rep(0, 3)
if(w_prior$type == "GBP" || abs(bet) > 1e-9){
cntw <- 0
}
if(v_prior$type == "GBP"){
cntv <- 0
}
tX <- Matrix::t(X)
k=1
if(k == lag_beta) s_beta <- s_beta_hold
move <- move_type(M, maxBasis, moveProbs)
move
#Propose a new basis function
J_cand <- sample(maxInt, 1, prob=Iw0)
u_cand <- sample(p, J_cand, replace=FALSE, prob=Zw0)
s_cand <- 1 - 2*rbinom(J_cand, 1, 0.5)
t_cand <- runif(J_cand)
#B_new <- rep(1, N)
#for(j in 1:J_cand) B_new <- B_new * pmax(0, s_cand[j]*(X[,u_cand[j]]-t_cand[j]))
B_new <- makeBasis(s_cand,u_cand,t_cand,tX,1)
B_new
npart
sum(B_new > 0)
B_cand  <- cbind(B, B_new)
U_cand  <- tryCatch(solve(symchol(t(B_cand)%*%Vinv%*%B_cand + scale/tau*Diagonal(M+2))), error=function(e) FALSE)
U_cand
if(isFALSE(U_cand)){
log_accept_prob_B <- -Inf
}else{
U2_cand <- t(z/v)%*%B_cand%*%U_cand
log_accept_prob_B <- sum(log(abs(diag(U_cand))))-sum(log(abs(diag(U)))) +
1/(2*w*scale)*(TCP(U2_cand)-TCP(U2))
#Add line here if Sigma != Identity
log_accept_prob_B <- log_accept_prob_B+log(scale)/2-log(tau)/2+log(lam)+log(moveProbs[2])-log(moveProbs[1])-log(M+1)-log(maxInt)-lchoose(p,J_cand)
log_accept_prob_B <- log_accept_prob_B-log(Iw0[J_cand]/sum(Iw0))-log(dmwnchBass(Zw0, u_cand))
}
log_accept_prob_B
log(runif(1)) < as.numeric(log_accept_prob_B)
if(log(runif(1)) < as.numeric(log_accept_prob_B)){
cnt2[1] <- cnt2[1] + 1
B <- B_cand
U <- U_cand
U2 <- U2_cand
Iw0[J_cand] <- Iw0[J_cand] + 1
Zw0[u_cand] <- Zw0[u_cand] + 1
M <- M + 1
lookup[[nlook]] <- list(J=J_cand, s=s_cand, t=t_cand, u=u_cand)
basis_index <- c(basis_index, nlook)
nlook <- nlook + 1
}
# ======================================================
#        GIBBS STEPS
# ======================================================
a <- TCP(U, U2) + sqrt(scale*w)*(U%*%rnorm(M+1))
yhat <- B%*%a
r <- y - yhat
pen <- sum(a^2)
lam <- rgamma(1, a_lambda[1]+M, b_lambda+1)
tau <- 1/rgamma(1, a_tau+(M+1)/2, b_tau+pen/(2*w))
bet <- rnorm(1, (s_beta^2*sum(r)/sqrt(w) + scale*m_beta)/(s_beta^2*sum(v) + scale),
sqrt(scale*s_beta^2/(s_beta^2*sum(v)+scale)))
gam <- rnorm(1, (s_gamma^2*N+m_gamma)/(s_gamma^2*sum(v)+1), s_gamma/sqrt(s_gamma^2*sum(v)+1))
gam
bet
tau
lam
pen
r
sum(r^2)
w_tform <- rmpon_sun(1,
N+M+w_prior$p-1,
0.5*(w_prior$b + sum(r^2/v)/scale + pen/tau),
bet*sum(r)/scale/(sum(r^2/v)/scale + pen/tau))
w_tform
w <- w_tform^-2
w
w_prior$type == "GIG"
if(v_prior$type == "GIG"){
v <- rgig2.vec(p=v_prior$p-1/2,
a=v_prior$a+bet^2/scale,
b=as.numeric(v_prior$b + r^2/(w*scale)))
}else{
v <- rgbp.vec(as.numeric(v), v_prior, w, scale, as.numeric(r), bet)
}
z    <- y - bet*v*sqrt(w) - sqrt(w)*bet/gam
Vinv <- Matrix::Diagonal(x=1/v)
U    <- solve(symchol(t(B)%*%Vinv%*%B + scale/tau*Diagonal(M+1)))
U2   <- t(z/v)%*%B%*%U
v_prior
?nwbass2
